<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Last.fm → Spotify Monthly Top 50 (Client-side)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; max-width:900px; margin:2rem auto; padding:1rem; }
    button { padding:.6rem 1rem; margin:.25rem; }
    input { padding:.4rem; margin:.25rem; }
    pre { background:#f6f8fa; padding:1rem; overflow:auto }
    .status { margin:.5rem 0; color:#333; }
  </style>
</head>
<body>
  <h1>Last.fm → Spotify: Monthly Top 50 (Client-side)</h1>
  <p>This client-side app gets your last.fm top 50 tracks for the past month and creates/updates a public Spotify playlist.</p>

  <div>
    <label>Spotify Client ID: <input id="clientId" /></label><br/>
    <label>Redirect URI: <input id="redirectUri" /></label><br/>
    <label>Last.fm username: <input id="lastfmUser" placeholder="your_lastfm_username"/></label><br/>
    <label>Last.fm API key: <input id="lastfmKey" placeholder="LASTFM_API_KEY"/></label><br/>
  </div>

  <div style="margin-top:.6rem;">
    <button id="btnLogin">Login with Spotify</button>
    <button id="btnLogout">Logout</button>
    <button id="btnSync">Sync Now</button>
    <label><input type="checkbox" id="autoSync"/> Auto-sync every 24h while page open</label>
  </div>

  <div class="status" id="status">Not logged in</div>
  <h3>Logs</h3>
  <pre id="log"></pre>

<script>
/*
  Client-side Last.fm -> Spotify Monthly Top 50
  - Uses Authorization Code + PKCE to get tokens without client secret
  - Replace/CREATE a public playlist for the user
  - WARNING: Last.fm API key is exposed client-side; use only for personal use.
*/

// ----- CONFIG DEFAULTS (replace in UI) -----
const DEFAULT_SPOTIFY_CLIENT_ID = "1f763981327249d0a98b57fb669aafe5";
const DEFAULT_REDIRECT_URI = "https://screebelinos-playlist-updater.netlify.app/"; // e.g. http://localhost:5500/
const DEFAULT_LASTFM_API_KEY = "9812dcf83280f95f079f387003fe0b71";
// --------------------------------------------

const SCOPE = "playlist-modify-public playlist-modify-private user-read-private";
const LASTFM_LIMIT = 50;
const LASTFM_PERIOD = "1month"; // user's choice: 1month
const PLAYLIST_NAME_PREFIX = "Last.fm Monthly Top 50"; // playlist name will include month-year

// simple UI helpers
const logEl = document.getElementById('log');
const statusEl = document.getElementById('status');
function log(...args){ console.log(...args); logEl.textContent += args.map(a=>typeof a==="object"?JSON.stringify(a,null,2):String(a)).join(' ') + '\\n'; logEl.scrollTop = logEl.scrollHeight; }
function setStatus(s){ statusEl.textContent = s; }

// inputs
const clientIdInput = document.getElementById('clientId');
const redirectUriInput = document.getElementById('redirectUri');
const lastfmUserInput = document.getElementById('lastfmUser');
const lastfmKeyInput = document.getElementById('lastfmKey');

// buttons
const btnLogin = document.getElementById('btnLogin');
const btnLogout = document.getElementById('btnLogout');
const btnSync = document.getElementById('btnSync');
const autoSyncCheckbox = document.getElementById('autoSync');

// load defaults into inputs if available
clientIdInput.value = DEFAULT_SPOTIFY_CLIENT_ID;
redirectUriInput.value = DEFAULT_REDIRECT_URI;
lastfmKeyInput.value = DEFAULT_LASTFM_API_KEY;

// token storage keys
const STORAGE = {
  accessToken: 'lf_sp_access_token',
  refreshToken: 'lf_sp_refresh_token',
  tokenExpiresAt: 'lf_sp_token_expires_at',
  codeVerifier: 'lf_sp_code_verifier',
  playlistId: 'lf_sp_playlist_id',
  spotifyUserId: 'lf_sp_user_id'
};

// Helpers for PKCE
function randomString(length) {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
  let result = '';
  const array = new Uint8Array(length);
  window.crypto.getRandomValues(array);
  for (let i = 0; i < length; i++) {
    result += chars[array[i] % chars.length];
  }
  return result;
}
function base64urlEncode(buffer) {
  return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)))
    .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}
async function sha256(plain) {
  const encoder = new TextEncoder();
  const data = encoder.encode(plain);
  const hash = await window.crypto.subtle.digest('SHA-256', data);
  return hash;
}
async function generateCodeChallenge(verifier) {
  const hashed = await sha256(verifier);
  return base64urlEncode(hashed);
}

// OAuth actions
async function startAuth() {
  const clientId = clientIdInput.value.trim();
  const redirectUri = redirectUriInput.value.trim();
  if (!clientId || !redirectUri) { alert("Set Spotify Client ID and Redirect URI in the inputs."); return; }

  const verifier = randomString(128);
  localStorage.setItem(STORAGE.codeVerifier, verifier);
  const challenge = await generateCodeChallenge(verifier);

  const authUrl = new URL('https://accounts.spotify.com/authorize');
  authUrl.searchParams.set('client_id', clientId);
  authUrl.searchParams.set('response_type', 'code');
  authUrl.searchParams.set('redirect_uri', redirectUri);
  authUrl.searchParams.set('scope', SCOPE);
  authUrl.searchParams.set('code_challenge_method', 'S256');
  authUrl.searchParams.set('code_challenge', challenge);
  // show dialog
  window.location = authUrl.toString();
}

// After redirect: parse code
async function handleRedirectCallback() {
  const params = new URLSearchParams(window.location.search);
  const code = params.get('code');
  const error = params.get('error');
  if (error) {
    log("Spotify auth error:", error);
    return;
  }
  if (code) {
    // remove code from url
    if (window.history && window.history.replaceState) {
      const clean = location.origin + location.pathname;
      window.history.replaceState({}, document.title, clean);
    }
    await exchangeCodeForTokens(code);
  }
}

// Exchange code for tokens (PKCE)
async function exchangeCodeForTokens(code) {
  const clientId = clientIdInput.value.trim();
  const redirectUri = redirectUriInput.value.trim();
  const verifier = localStorage.getItem(STORAGE.codeVerifier);
  if (!clientId || !redirectUri || !verifier) { log('Missing PKCE data'); return; }

  const body = new URLSearchParams({
    grant_type: 'authorization_code',
    code,
    redirect_uri: redirectUri,
    client_id: clientId,
    code_verifier: verifier
  });

  try {
    const resp = await fetch('https://accounts.spotify.com/api/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: body.toString()
    });
    const data = await resp.json();
    if (!resp.ok) { log('Token exchange error', data); alert('Token exchange failed; check console.'); return; }
    storeTokens(data);
    log('Got tokens', data);
    await fetchSpotifyProfileAndStore();
    setStatus('Logged in (tokens stored)');
  } catch (e) {
    log('Token exchange exception', e);
  }
}

// store tokens
function storeTokens(data) {
  if (data.access_token) localStorage.setItem(STORAGE.accessToken, data.access_token);
  if (data.refresh_token) localStorage.setItem(STORAGE.refreshToken, data.refresh_token);
  if (data.expires_in) {
    const expiry = Date.now() + (data.expires_in * 1000) - (30*1000); // 30s safety margin
    localStorage.setItem(STORAGE.tokenExpiresAt, expiry.toString());
  }
}

// refresh access token using refresh token (attempt)
async function refreshAccessTokenIfNeeded() {
  const expiresAt = parseInt(localStorage.getItem(STORAGE.tokenExpiresAt) || '0', 10);
  if (Date.now() < expiresAt - 1000) { return true; } // still valid
  const refresh_token = localStorage.getItem(STORAGE.refreshToken);
  const clientId = clientIdInput.value.trim();
  if (!refresh_token || !clientId) { log('No refresh token or client id'); return false; }

  const body = new URLSearchParams({
    grant_type: 'refresh_token',
    refresh_token,
    client_id: clientId
  });
  try {
    const resp = await fetch('https://accounts.spotify.com/api/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: body.toString()
    });
    const data = await resp.json();
    if (!resp.ok) { log('Refresh token failed', data); return false; }
    storeTokens(data);
    log('Refreshed token', data);
    return true;
  } catch (e) {
    log('Refresh exception', e);
    return false;
  }
}

async function fetchSpotifyProfileAndStore() {
  const ok = await refreshAccessTokenIfNeeded();
  if (!ok) return;
  const token = localStorage.getItem(STORAGE.accessToken);
  const resp = await fetch('https://api.spotify.com/v1/me', {
    headers: { 'Authorization': 'Bearer ' + token }
  });
  const data = await resp.json();
  if (resp.ok) {
    localStorage.setItem(STORAGE.spotifyUserId, data.id);
    log('Spotify user id', data.id);
  } else {
    log('Failed to fetch profile', data);
  }
}

// Logout
function logout() {
  ['accessToken','refreshToken','tokenExpiresAt','codeVerifier','playlistId','spotifyUserId'].forEach(k => {
    const key = STORAGE[k];
    if (key) localStorage.removeItem(key);
  });
  setStatus('Logged out');
  log('Logged out; cleared local storage keys.');
}

// Last.fm fetch
async function fetchLastFmTopTracks(user, apiKey, limit=50, period='1month') {
  const url = new URL('https://ws.audioscrobbler.com/2.0/');
  url.searchParams.set('method', 'user.getTopTracks');
  url.searchParams.set('user', user);
  url.searchParams.set('api_key', apiKey);
  url.searchParams.set('format', 'json');
  url.searchParams.set('period', period);
  url.searchParams.set('limit', String(limit));
  const r = await fetch(url.toString());
  const j = await r.json();
  if (!r.ok || j.error) {
    throw new Error('Last.fm error: ' + (j.message || r.statusText));
  }
  const tracks = (j.toptracks && j.toptracks.track) ? j.toptracks.track : [];
  // Normalize: array of {artist, name}
  return tracks.map(t => ({ artist: t.artist.name, name: t.name }));
}

// Spotify search per track (best-effort)
async function searchSpotifyTrack(track, artist) {
  await refreshAccessTokenIfNeeded();
  const token = localStorage.getItem(STORAGE.accessToken);
  const q = `track:${track} artist:${artist}`;
  const url = new URL('https://api.spotify.com/v1/search');
  url.searchParams.set('q', q);
  url.searchParams.set('type', 'track');
  url.searchParams.set('limit', '1');
  const resp = await fetch(url.toString(), {
    headers: { Authorization: 'Bearer ' + token }
  });
  const js = await resp.json();
  if (!resp.ok) {
    log('Spotify search failed', js);
    return null;
  }
  const items = js.tracks && js.tracks.items;
  if (items && items.length) return items[0].uri;
  // fallback: search by track only
  const url2 = new URL('https://api.spotify.com/v1/search');
  url2.searchParams.set('q', `track:${track}`);
  url2.searchParams.set('type', 'track');
  url2.searchParams.set('limit', '1');
  const resp2 = await fetch(url2.toString(), { headers: { Authorization: 'Bearer ' + token }});
  const js2 = await resp2.json();
  if (resp2.ok && js2.tracks && js2.tracks.items && js2.tracks.items.length) {
    return js2.tracks.items[0].uri;
  }
  return null;
}

// Create playlist (public) or return existing playlist id
async function getOrCreatePlaylistId(userId, name, description="") {
  await refreshAccessTokenIfNeeded();
  const token = localStorage.getItem(STORAGE.accessToken);
  // Try to find an existing playlist with same name
  let playlistsUrl = new URL(`https://api.spotify.com/v1/users/${userId}/playlists`);
  playlistsUrl.searchParams.set('limit', '50');
  let found = null;
  while (playlistsUrl) {
    const resp = await fetch(playlistsUrl.toString(), { headers: { Authorization: 'Bearer ' + token }});
    if (!resp.ok) break;
    const js = await resp.json();
    if (js.items) {
      found = js.items.find(p => p.name === name);
      if (found) {
        localStorage.setItem(STORAGE.playlistId, found.id);
        return found.id;
      }
    }
    if (js.next) {
      playlistsUrl = new URL(js.next);
    } else {
      playlistsUrl = null;
    }
  }
  // not found -> create
  const createResp = await fetch(`https://api.spotify.com/v1/users/${userId}/playlists`, {
    method: 'POST',
    headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
    body: JSON.stringify({ name, description, public: true })
  });
  const createJs = await createResp.json();
  if (!createResp.ok) { throw new Error('Playlist creation failed: ' + (createJs.error && createJs.error.message)); }
  localStorage.setItem(STORAGE.playlistId, createJs.id);
  return createJs.id;
}

// Replace playlist tracks (PUT to replace)
async function replacePlaylistTracks(playlistId, uris) {
  await refreshAccessTokenIfNeeded();
  const token = localStorage.getItem(STORAGE.accessToken);
  const resp = await fetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, {
    method: 'PUT',
    headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
    body: JSON.stringify({ uris })
  });
  if (!resp.ok) {
    const js = await resp.json();
    throw new Error('Failed to replace playlist tracks: ' + (js.error && js.error.message));
  }
  return true;
}

// MAIN SYNC flow
async function syncNow() {
  const clientId = clientIdInput.value.trim();
  const redirectUri = redirectUriInput.value.trim();
  const lastfmUser = lastfmUserInput.value.trim();
  const lastfmKey = lastfmKeyInput.value.trim();
  if (!clientId || !redirectUri || !lastfmUser || !lastfmKey) {
    alert("Fill Spotify Client ID, Redirect URI, Last.fm username and Last.fm API key.");
    return;
  }

  setStatus('Sync started...');
  log('Fetching Last.fm top tracks...');
  let lastfmTracks;
  try {
    lastfmTracks = await fetchLastFmTopTracks(lastfmUser, lastfmKey, LASTFM_LIMIT, LASTFM_PERIOD);
    log('Last.fm tracks:', lastfmTracks.length);
  } catch (e) {
    log('Last.fm fetch failed', e.message || e);
    setStatus('Last.fm fetch failed: ' + (e.message || e));
    return;
  }

  // ensure tokens ok
  const refreshed = await refreshAccessTokenIfNeeded();
  if (!refreshed) { setStatus('Not logged in to Spotify. Please login.'); log('No valid Spotify token'); return; }

  // ensure we have spotify user id
  let spotifyUserId = localStorage.getItem(STORAGE.spotifyUserId);
  if (!spotifyUserId) {
    await fetchSpotifyProfileAndStore();
    spotifyUserId = localStorage.getItem(STORAGE.spotifyUserId);
    if (!spotifyUserId) { setStatus('Failed to fetch Spotify user id'); return; }
  }

  // generate playlist name with month/year
  const now = new Date();
  const month = now.toLocaleString(undefined, { month: 'long' });
  const year = now.getFullYear();
  const playlistName = `${PLAYLIST_NAME_PREFIX} — ${month} ${year}`;
  const playlistDesc = `Updated from Last.fm top ${LASTFM_LIMIT} for ${LASTFM_PERIOD} on ${now.toISOString().slice(0,10)}.`;

  setStatus('Searching/creating playlist...');
  let playlistId;
  try {
    playlistId = await getOrCreatePlaylistId(spotifyUserId, playlistName, playlistDesc);
    log('Playlist id:', playlistId);
  } catch (e) {
    log('Playlist creation/search failed', e);
    setStatus('Playlist error: ' + e.message);
    return;
  }

  // search each track and collect URIs
  setStatus('Searching tracks on Spotify (best-effort)...');
  const uris = [];
  for (let i = 0; i < lastfmTracks.length; i++) {
    const t = lastfmTracks[i];
    try {
      const uri = await searchSpotifyTrack(t.name, t.artist);
      if (uri) {
        uris.push(uri);
        log(`Matched: ${t.artist} - ${t.name} -> ${uri}`);
      } else {
        log(`No match: ${t.artist} - ${t.name}`);
      }
    } catch (e) {
      log('Search error for', t, e);
    }
    // small delay to not hit search rate limits
    await new Promise(res => setTimeout(res, 120));
  }

  // replace playlist with URIs (only first 100 URIs per request allowed; we're <=50)
  try {
    await replacePlaylistTracks(playlistId, uris);
    log('Playlist updated with', uris.length, 'tracks.');
    setStatus('Sync complete — ' + uris.length + ' tracks added.');
  } catch (e) {
    log('Failed to replace playlist', e);
    setStatus('Failed to update playlist: ' + e.message);
  }
}

// Handler for page load: check for code returned from Spotify
window.addEventListener('load', async () => {
  // populate inputs if localStorage has known client id/uri? no — keep manual
  await handleRedirectCallback();
  // update status based on token presence
  if (localStorage.getItem(STORAGE.accessToken)) {
    setStatus('Logged in (token present)');
    await fetchSpotifyProfileAndStore();
  } else {
    setStatus('Not logged in');
  }
});

// wire buttons
btnLogin.addEventListener('click', async () => {
  // save UI inputs to local storage (optional)
  startAuth();
});
btnLogout.addEventListener('click', () => { logout(); });

btnSync.addEventListener('click', async () => {
  btnSync.disabled = true;
  try { await syncNow(); } finally { btnSync.disabled = false; }
});

autoSyncCheckbox.addEventListener('change', () => {
  if (autoSyncCheckbox.checked) {
    // default every 24 hours (86400000 ms). For testing you can lower.
    window._lf_autoSyncInterval = setInterval(() => {
      log('Auto-sync triggered');
      syncNow();
    }, 24 * 60 * 60 * 1000); // 24h
    log('Auto-sync enabled (every 24 hours while page open)');
  } else {
    if (window._lf_autoSyncInterval) {
      clearInterval(window._lf_autoSyncInterval);
      window._lf_autoSyncInterval = null;
      log('Auto-sync disabled');
    }
  }
});

</script>
</body>
</html>
